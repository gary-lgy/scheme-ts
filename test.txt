[
{ program: "(define add (lambda (x) (+ x 1)))", 
tests: 
[ { input: "(add 2)", expected: "3"},
  { input: "(add 10)", expected: "11"}
]
},

{ program: "(define my-last(lambda  (x)(if (null? (cdr x)) x (my-last (cdr x)))))", 
  tests: 
  [ { input: "(my-last '(a b c d))", expected: "(d)"},
    { input: "(my-last '(1 2 3))", expected: "(3)"}
  ]
},

{ program: "(define (my-but-last liste)(if (or (null? liste) (null? (cdr liste))(null? (cddr liste))) liste (my-but-last (cdr liste))))", 
  tests: 
  [ { input: "(my-but-last '(a b c d))", expected: "(c d)"},
    { input: "(my-but-last '(1 2 3))", expected: "(2 3)"}
  ]
},

{ program: "(define (element-at liste numero) (if (= 1 numero) (car liste)(element-at (cdr liste) (- numero 1))))", 
  tests: 
  [ { input: "(element-at '(a b c d e) 3)", expected: "c"},
    { input: "(element-at '(1 2 3 4 5) 3)", expected: "3"}
  ]
},

{ program: "(define (number-of-elements liste) (if (null?  liste) 0 (+ 1 (number-of-elements (cdr liste)))))", 
  tests: 
  [ { input: "(number-of-elements '(a b h j (k t) l l j))", expected: "8"},
    { input: "(number-of-elements '(a b h j k t l l j))", expected: "9"}
  ]
},


{ program: "(define (my-reverse liste)(if (null? liste) '() (append (my-reverse (cdr liste)) (list (car liste)))))", 
  tests: 
  [ { input: "(my-reverse '(s ff k h (k l) l t))", expected: "(t l (k l) h k ff s)"},
    { input: "(my-reverse '(1 2 3 4 5))", expected: "(5 4 3 2 1)"}
  ]
},

{ program: "(define (reverse liste) (if (null? liste) '() (append (reverse (cdr liste)) (list (car liste))))) (define (is-palindrome liste)(equal? liste (reverse liste)))", 
  tests: 
  [ { input: "(is-palindrome '(x (a b) a m a (a b) x))", expected: "true"},
    { input: "(is-palindrome '(my-reverse '(1 2 3 4 5)))", expected: "false"}
  ]
},

{ program: "(define (my-flatten liste) (if (null? liste) '() (append (if (list? (car liste)) (my-flatten (car liste))(list (car liste))) (my-flatten (cdr liste)))))", 
  tests: 
  [ { input: "(my-flatten '(a (b (c d) e)))", expected: "(a b c d e)"}
  ]
},

{ program: "(define (my-reverse liste)(if (null? liste) '() (append (my-reverse (cdr liste)) (list (car liste)))))", 
  tests: 
  [ { input: "(my-reverse '(s ff k h (k l) l t))", expected: "(t l (k l) h k ff s)"},
    { input: "(my-reverse '(1 2 3 4 5))", expected: "(5 4 3 2 1)"}
  ]
},

{ program: "(define (compress liste) (if (or (null? liste) (null? (cdr liste))) liste (let ((compressed-cdr (compress (cdr liste)))) (if (equal? (car liste) (car compressed-cdr)) compressed-cdr (cons (car liste) compressed-cdr)))))", 
  tests: 
  [ { input: "(compress '(a a a a b (c c) (c c) (a b) (a b) a a d e e e e))", expected: "(a b (c c) (a b) a d e)"},
    { input: "(compress '(1 1 1 (2 2) 3))", expected: "(1 (2 2) 3)"}
  ]
},        

{ program: "(define (pack liste) (if (null? liste) (list liste) (let ((packed-cdr (pack (cdr liste)))) (cond ((null? (car packed-cdr)) (list (list (car liste)))) ((equal? (car liste) (caar packed-cdr)) (cons (cons (car liste) (car packed-cdr)) (cdr packed-cdr))) (else (cons (list (car liste)) packed-cdr))))))", 
  tests: 
  [ { input: "(pack '(a a a a b c c a a d e (e) (e) e))", expected: "((a a a a) (b) (c c) (a a) (d) (e) ((e) (e)) (e))"}  
  ]
},

{ program: "
(define (pack liste)
(if (null? liste)
    (list liste)                                    
    (let ((packed-cdr (pack (cdr liste))))
      (cond ((null? (car packed-cdr))               
             (list (list (car liste))))
            ((equal? (car liste) (caar packed-cdr)) 
             (cons (cons (car liste)
                         (car packed-cdr))
                   (cdr packed-cdr)))
            (else (cons (list (car liste))          
                        packed-cdr))))))
(define (encode liste)
(define (encode-helper packed-list)
  (if (null? packed-list)
      '()
      (cons (list (length (car packed-list))
                  (caar packed-list))
            (encode-helper (cdr packed-list)))))
(encode-helper (pack liste)))", 
  tests: 
  [ { input: "(encode '(a a a a b c c a a d e e e e))", expected: "((4 a) (1 b) (2 c) (2 a) (1 d) (4 e))"}
  ]
},

{ program: "
(define (pack liste)
(if (null? liste)
    (list liste)                                    
    (let ((packed-cdr (pack (cdr liste))))
      (cond ((null? (car packed-cdr))               
             (list (list (car liste))))
            ((equal? (car liste) (caar packed-cdr)) 
             (cons (cons (car liste)
                         (car packed-cdr))
                   (cdr packed-cdr)))
            (else (cons (list (car liste))          
                        packed-cdr))))))
(define (encode liste)
(define (encode-helper packed-list)
  (if (null? packed-list)
      '()
      (cons (list (length (car packed-list))
                  (caar packed-list))
            (encode-helper (cdr packed-list)))))
(encode-helper (pack liste)))
(define (encode-modified liste)
(define (simplify encoded-list)
  (if (null? encoded-list)
      '()
      (cons (if (= 1 (caar encoded-list))
                (cadar encoded-list)
                (car encoded-list))
            (simplify (cdr encoded-list)))))
(simplify (encode liste)))

(define (decode-rl encoded-list)
(define (expand element count)
  (if (= count 0)
      '()
      (cons element
            (expand element (- count 1)))))
(cond ((null? encoded-list) '())
      ((not (list? (car encoded-list)))
       (append (list (car encoded-list))
               (decode-rl (cdr encoded-list))))
      (else (append (expand (cadar encoded-list)
                            (caar encoded-list))				
                    (decode-rl (cdr encoded-list))))))
 ", 
  tests: 
  [ { input: "(decode-rl (encode-modified '(a a a a b c c a a d e e e e)))", expected: "(a a a a b c c a a d e e e e)"}  
  ]
},

{ program: "(define (pack liste)
(if (null? liste)
    (list liste)                                    
    (let ((packed-cdr (pack (cdr liste))))
      (cond ((null? (car packed-cdr))               
             (list (list (car liste))))
            ((equal? (car liste) (caar packed-cdr)) 
             (cons (cons (car liste)
                         (car packed-cdr))
                   (cdr packed-cdr)))
            (else (cons (list (car liste))          
                        packed-cdr))))))
(define (encode liste)
(define (encode-helper packed-list)
  (if (null? packed-list)
      '()
      (cons (list (length (car packed-list))
                  (caar packed-list))
            (encode-helper (cdr packed-list)))))
(encode-helper (pack liste)))

(define (encode-modified liste)
(define (simplify encoded-list)
  (if (null? encoded-list)
      '()
      (cons (if (= 1 (caar encoded-list))
                (cadar encoded-list)
                (car encoded-list))
            (simplify (cdr encoded-list)))))
(simplify (encode liste)))", 
  tests: 
  [ { input: "(encode-modified '(a a a a b c c a a d e e e e))", expected: "((4 a) b (2 c) (2 a) d (4 e))"}
  ]
},

{ program: "(define (encode-direct list-to-encode)
(define (simplify liste)
  (if (null? liste)
      '()
      (cons (if (= 1 (caar liste))
                (cadar liste)
                (car liste))
            (simplify (cdr liste)))))
(define (encode-direct-helper liste)
  (if (null? liste)
      '()                                                     
      (let ((encoded-cdr (encode-direct-helper (cdr liste))))
        (cond ((null? encoded-cdr) (list (list 1
                                               (car liste)))) 
              ((equal? (car liste)
                       (cadar encoded-cdr))
               (cons (list (+ 1 (caar encoded-cdr))           
                           (car liste))
                     (cdr encoded-cdr)))
              (else (cons (list 1                            
                                (car liste))
                          encoded-cdr))))))
(simplify (encode-direct-helper list-to-encode)))", 
  tests: 
  [ { input: "(encode-direct '(a a a a b c c a a d e e e e))", expected: "((4 a) b (2 c) (2 a) d (4 e))"}
  ]
},

{ program: "(define (dupli liste) (if (null? liste) '()  (append (list (car liste) (car liste)) (dupli (cdr liste)))))", 
  tests: 
  [ { input: "(dupli '(a b c c d))", expected: "(a a b b c c c c d d)"}
  ]
},

{ program: "(define (repli liste count) (define (replicate-element element how-many) (if (= how-many 0) '() (cons element (replicate-element element (- how-many 1))))) (if (null? liste) '() (append (replicate-element (car liste count) (repli (cdr liste) count))))", 
  tests: 
  [ { input: "(repli '(a b c) 9)", expected: "(a a a a a a a a a b b b b b b b b b c c c c c c c c c)"}
  ]
},

{ program: "(define (dupli liste) (if (null? liste) '()  (append (list (car liste) (car liste)) (dupli (cdr liste)))))", 
  tests: 
  [ { input: "(dupli '(a b c c d))", expected: "(a a b b c c c c d d)"}
  ]
},

{ program: "(define (drop liste position) (define (drop-helper temp-list temp-position) (cond ((null? temp-list) '()) ((= 1 temp-position) (drop-helper (cdr temp-list) position)) (else (cons (car temp-list) (drop-helper (cdr temp-list) (- temp-position 1)))))) (drop-helper liste position))", 
  tests: 
  [ { input: "(drop '(a b c d e f g h i k) 3)", expected: "(a b d e g h k)"}
  ]
},


{ program: "(define (split liste first-part-length) (if (= 0 first-part-length) (list '() liste) (let ((splited-cdr (split (cdr liste)  (- first-part-length 1)))) (list (cons (car liste)  (car splited-cdr)) (cadr splited-cdr)))))", 
  tests: 
  [ { input: "(split '(a b c d e f g h i k) 3)", expected: "((a b c) (d e f g h i k))"}
  ]
},

{ program: "(define (split liste first-part-length) (if (= 0 first-part-length) (list '() liste) (let ((splited-cdr (split (cdr liste)  (- first-part-length 1)))) (list (cons (car liste)  (car splited-cdr)) (cadr splited-cdr))))) (define (slice liste start stop) (car (split (cadr (split liste (- start 1))) (+ 1 (- stop start)))))", 
  tests: 
  [ { input: "(slice '(a b c d e f g h i k) 3 7)", expected: "(c d e f g)"}
  ]
},

{ program: "(define (split liste first-part-length) (if (= 0 first-part-length) (list '() liste) (let ((splited-cdr (split (cdr liste)  (- first-part-length 1)))) (list (cons (car liste)  (car splited-cdr)) (cadr splited-cdr))))) (define (slice liste start stop) (car (split (cadr (split liste (- start 1))) (+ 1 (- stop start))))) (define (rotate liste arg) (if (null? liste) '() (let ((splited-liste (split liste  (modulo arg (length liste))))) (append (cadr splited-liste) (car splited-liste)))))", 
  tests: 
  [ { input: "(rotate '(a b c d e f g h) 3)", expected: "(d e f g h a b c)"},
    { input: "(rotate '(a b c d e f g h) -2)", expected: "(g h a b c d e f)"}
  ]
},

{ program: "(define (remove-at liste place) (if (= 1 place) (cdr liste) (cons (car liste) (remove-at (cdr liste) (- place 1)))))", 
  tests: 
  [ { input: "(remove-at '(a b c d) 2)", expected: "(a c d)"}
  ]
},


{ program: "(define (insert-at element liste place) (if (= 1 place) (cons element liste)  (cons (car liste) (insert-at element (cdr liste) (- place 1)))))", 
  tests: 
  [ { input: "(insert-at 'alfa '(a b c d) 2)", expected: "(a alfa b c d)"}
  ]
},

{ program: "(define (range start stop) (if (= start stop) (list stop) (cons start (range (+ start 1) stop))))", 
  tests: 
  [ { input: "(range 4 9)", expected: "(4 5 6 7 8 9)"}
  ]
},



{ program: "(define (combinaison k liste)
(define (add-element x liste)
  (if (null? liste)
      '()
      (cons (cons x (car liste))
            (add-element x (cdr liste)))))
(cond ((or (= 0 k) (> k (length liste))) '(()))
      ((= k (length liste)) (list liste))
      (else (append (combinaison k (cdr liste))
            (add-element (car liste)
                         (combinaison (- k 1) (cdr liste)))))))", 
  tests: 
  [ { input: "(combinaison 3 '(a b c d e f))", expected: "((d e f) (c e f) (c d f) (c d e) (b e f) (b d f) (b d e) (b c f) (b c e) (b c d) (a e f) (a d f) (a d e) (a c f) (a c e) (a c d) (a b f) (a b e) (a b d) (a b c))"}
  ]
},



{ program: "(define (my-gcd n m)(if (= m 0) n (my-gcd m (modulo n m))))", 
  tests: 
  [ { input: "(my-gcd 36 63)", expected: "9"}
  ]
},

{ program: "(define (my-gcd n m) (if (= m 0) n (my-gcd m (modulo n m)))) (define (my-coprime n m) (= (my-gcd n m) 1))", 
  tests: 
  [ { input: "(my-coprime 35 64)", expected: "true"}
  ]
},

{ program: "
(define (my-gcd n m)
(if (= m 0)
    n
    (my-gcd m (modulo n m))))
(define (my-coprime n m)
(= (my-gcd n m) 1))
(define (my-totient-phi n)
(define (my-totient-phi-aux n i)
  (cond ((<= n i) 0)
        ((my-coprime n i) (+ 1 (my-totient-phi-aux n (+ 1 i))))
        (else (my-totient-phi-aux n (+ 1 i)))))
(cond ((< n 1) 0)
      ((= n 1) 1)
      (else (my-totient-phi-aux n 1))))", 
  tests: 
  [ { input: "(my-totient-phi 7)", expected: "6"},
    { input: "(my-totient-phi 1)", expected: "1"},
    { input: "(my-totient-phi 10)", expected: "4"}
  ]
},



{ program: "
(define (my-length xs)
  (cond ((null? xs) 0)
        (else (+ 1 (my-length (cdr xs))))))
(define (my-is-empty-tree candidate)
  (null? candidate))

(define (my-is-nonempty-tree candidate)
  (and (list? candidate)
       (= (my-length candidate) 3)
       (symbol? (car candidate))))

(define (my-is-tree candidate)
  (define (my-is-tree-aux candidate)
    (if (my-is-empty-tree candidate)
        #t
        (if (not (my-is-nonempty-tree candidate))
            #f
            (and (my-is-tree-aux (cadr candidate))
                 (my-is-tree-aux (caddr candidate))))))
  (my-is-tree-aux candidate))", 
  tests: 
  [ { input: "(my-is-tree '(a () ()))", expected: "true"},
    { input: "(my-is-tree '(a () "123"))", expected: "false"},
    { input: "(my-is-tree '(a (b () f) ()))", expected: "false"},
    { input: "(my-is-tree '(my-is-tree '(a (b () ())))", expected: "false"}
  ]
},


{ program: "
(define bank-account
  (let ((balance 10))
    (lambda (n)
    (set! balance (+ balance n))
    balance)))", 
    tests: 
    [ { input: "(bank-account 20)", expected: "30"},
      { input: "(bank-account -25)", expected: "-15"}
    ]
},

{ program: "
(define (fact n)
   (if (= n 1)
    1
    (* n (fact (- n 1)))))", 
    tests: 
    [ { input: "(fact 5)", expected: "120"}
      
    ]
},
{ program: "
(define (fact-tail n)
  (fact-rec n n))
(define (fact-rec n p)
  (if (= n 1)
      p
      (let ((m (- n 1)))
    (fact-rec m (* p m)))))", 
    tests: 
    [ { input: "(fact-tail 5)", expected: "120"}
      
    ]
},
{ program: "(define var 1)  (set! var (* var 10))", 
    tests: 
    [ { input: "var", expected: "10"}
      
    ]
},

{ program: "(define (range start stop)
(if (= start stop)
    (list stop)
    (cons start
          (range (+ start 1)
                 stop))))", 
    tests: 
    [ { input: "(range 4 9)", expected: "(4 5 6 7 8 9)"}
      
    ]
},


{ program: "(define (range start stop)
(if (= start stop)
    (list stop)
    (cons start
          (range (+ start 1)
                 stop))))", 
    tests: 
    [ { input: "(range 4 9)", expected: "(4 5 6 7 8 9)"}
      
    ]
},

{ program: "(define (deriv exp var)
(cond ((number? exp)
        0)
      ((variable? exp)
        (if (same-variable? exp var)
            1
            0))
      ((sum? exp)
        (make-sum (deriv (addend exp) var)
                  (deriv (augend exp) var)))
      ((product? exp)
        (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
      ((exponentiation? exp)                                    
        (let ((n (exponent exp))                                
              (u (base exp)))                                   
            (make-product                                       
                n                                               
                (make-product                                   
                    (make-exponentiation                        
                        u                                       
                        (- n 1))                                
                    (deriv u var)))))                           
      (else
        (error "unknown expression type -- DERIV" exp))))

;; exponentiation

(define (make-exponentiation base exponent)                         
(cond ((= exponent 0)                                           
        1)                                                      
      ((= exponent 1)                                           
        base)                                                   
      (else                                                     
        (list '** base exponent))))                             
                                                                
(define (exponentiation? x)                                         
(and (pair? x)                                                  
    (eq? (car x) '**)))                                         
                                                                
(define (base exp)                                                  
(cadr exp))                                                     
                                                                
(define (exponent exp)                                              
(caddr exp))                                                    

;; number

(define (=number? exp num)
(and (number? exp)
     (= exp num)))

;; variable

(define (variable? x)
(symbol? x))

(define (same-variable? v1 v2)
(and (variable? v1)
     (variable? v2)
     (eq? v1 v2)))

;; sum

(define (make-sum a1 a2)
(cond ((=number? a1 0)
        a2)
      ((=number? a2 0)
        a1)
      ((and (number? a1) (number? a2))
        (+ a1 a2))
      (else
        (list '+ a1 a2))))

(define (sum? x)
(and (pair? x)
     (eq? (car x) '+)))

(define (addend s)
(cadr s))

(define (augend s)
(caddr s))

;; product

(define (make-product m1 m2)
(cond ((or (=number? m1 0) (=number? m2 0))
        0)
      ((=number? m1 1)
        m2)
      ((=number? m2 1)
        m1)
      ((and (number? m1) (number? m2))
        (* m1 m2))
      (else
        (list '* m1 m2))))

(define (product? x)
(and (pair? x)
     (eq? (car x) '*)))

(define (multiplier p)
(cadr p))

(define (multiplicand p)
(caddr p))", 
    tests: 
    [ { input: "(deriv '(** x 0) 'x)", expected: "0"},
      { input: "(deriv '(** x 2) 'x)", expected: "(* 2 x)"},
      { input: "(deriv '(** x 3) 'x)", expected: "(* 3 (** x 2))"},
      { input: "(deriv '(** x 1) 'x)", expected: "1"}
    ]
},


{ program: "(define (make-leaf symbol weight)
(list 'leaf symbol weight))

(define (leaf? object)
(eq? (car object) 'leaf))

(define (symbol-leaf x)
(cadr x))

(define (weight-leaf x)
(caddr x))

;; tree

(define (make-code-tree left right)
(list left
      right
      (append (symbols left) (symbols right))
      (+ (weight left) (weight right))))

(define (left-branch tree)
(car tree))

(define (right-branch tree)
(cadr tree))

(define (symbols tree)
(if (leaf? tree)
    (list (symbol-leaf tree))
    (caddr tree)))

(define (weight tree)
(if (leaf? tree)
    (weight-leaf tree)
    (cadddr tree)))

(define (decode bits tree)
(define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
                (choose-branch (car bits) current-branch)))
            (if (leaf? next-branch)
                (cons (symbol-leaf next-branch)
                      (decode-1 (cdr bits) tree))
                (decode-1 (cdr bits) next-branch)))))
(decode-1 bits tree))

(define (choose-branch bit branch)
(cond ((= bit 0)
        (left-branch branch))
      ((= bit 1)
        (right-branch branch))
      (else
        (error "bad bit -- CHOOSE-BRANCH" bit))))

(define tree (make-code-tree (make-leaf 'A 4)
               (make-code-tree (make-leaf 'B 2)
                               (make-code-tree (make-leaf 'D 1)
                                               (make-leaf 'C 1)))))

(define msg '(0 1 1 0 0 1 0 1 0 1 1 1 0))", 
    tests: 
    [ { input: "(decode msg tree)", expected: "(A D A B B C A)"}
      
    ]
},


{ program: "
(define (f n)
    (if (< n 3)
        n
        (+ (f (- n 1))
           (* 2 (f (- n 2)))
           (* 3 (f (- n 3))))))", 
    tests: 
    [ { input: "(f 1)", expected: "1"},
      { input: "(f 3)", expected: "4"},
      { input: "(f 4)", expected: "11"}
    ]
},


{ program: "
(define (fringe tree)
    (cond ((null? tree)                         
            '())
          ((not (pair? tree))                   
            (list tree))
          (else
            (append (fringe (car tree))         
                    (fringe (cadr tree))))))
(define (count-leaves tree)
    (length (fringe tree)))", 
    tests: 
    [ { input: "(count-leaves (list (list 1 2) (list 3 4)))", expected: "4"}
      
    ]
},


{ program: "
(define (element-of-set? x set)
    (cond ((null? set)
            #f)
          ((equal? x (car set))
            #t)
          (else
            (element-of-set? x (cdr set)))))", 
    tests: 
    [ { input: "(element-of-set? 5 (list 1 3 5 7 9 7 5 3 1))", expected: "true"},
      { input: "(element-of-set? 10086 (list 1 3 5 7 9 7 5 3 1))", expected: "false"}
    ]
},


{ program: "
(define (adjoin-set x set)
    (cons x set))", 
    tests: 
    [ { input: "(adjoin-set 1 (list 2 3 4))", expected: "(1 2 3 4)"},
      { input: "(adjoin-set 1 (list 1 3 5 7 9))", expected: "(1 1 3 5 7 9)"}   
    ]
},


{ program: "
(define (union-set set another)
    (cond ((and (null? set) (null? another))
            '())
          ((null? set)
            another)
          ((null? another)
            set)
          (else
            (let ((x (car set)) (y (car another)))
                (cond ((= x y)
                        (cons x (union-set (cdr set) (cdr another))))
                      ((< x y)
                        (cons x (union-set (cdr set) another)))
                      ((> x y)
                        (cons y (union-set set (cdr another)))))))))", 
    tests: 
    [ { input: "(union-set '() (list 1 2 3))", expected: "(1 2 3)"},
      { input: "(union-set (list 1 2 3) (list 1 3 5))", expected: "(1 2 3 5)"},
      { input: "(union-set (list 1 2 3) (list 1 3 5 7 9))", expected: "(1 2 3 5 7 9)"}    
    ]
},


{ program: "
(define (cons x y)
    (lambda (m)
        (m x y)))

(define (car z)
    (z (lambda (p q) p)))

(define (cdr z)
    (z (lambda (p q) q)))", 
    tests: 
    [ { input: "(cdr (cons 1 2))", expected: "2"}   
    ]
},



{ program: "
(define (cont-frac N D k)

    (define (cf i)
        (if (= k i)
            (/ (N k) (D k))
            (/ (N i)
               (+ (D i) (cf (+ i 1))))))

    (cf 1))

(define (golden-ratio k)
    (+ 1
       (cont-frac (lambda (i) 1.0)
                  (lambda (i) 1.0)
                  k)))
", 
    tests: 
    [ { input: "(golden-ratio 1)", expected: "2"}  
    ]
},




{ program: "
(define (contents datum)
    (cond ((number? datum)
            datum)
          ((pair? datum)
            (cdr datum))
          (else
            (error "Bad tagged datum -- CONTENT" datum))))
", 
    tests: 
    [ { input: "(contents 10)", expected: "10"},
      { input: "(contents (cons 'rectangular (cons 3 4)))", expected: "(3 . 4)"}    
    ]
},


{ program: "
(define (pascal row col)
    (cond ((> col row)
            (error "unvalid col value"))
          ((or (= col 0) (= row col))
            1)
          (else (+ (pascal (- row 1) (- col 1))
                   (pascal (- row 1) col)))))
", 
    tests: 
    [ { input: "(pascal 4 0)", expected: "1"},
      { input: "(pascal 4 4)", expected: "1"},
      { input: "(pascal 4 2)", expected: "6"}      
    ]
},


{ program: "
(define (fold-right op initial sequence) 
   (if (null? sequence) 
       initial 
       (op (car sequence) 
           (fold-right op initial (cdr sequence))))) 
  
  
 (define (fold-left op initial sequence) 
   (define (iter result rest) 
     (if (null? rest) 
         result 
         (iter (op result (car rest)) 
               (cdr rest)))) 
   (iter initial sequence)) 

(define (reverse-using-right items) 
   (fold-right (lambda (first already-reversed) 
                 (append already-reversed (list first))) 
               nil 
               items)) 
  
 (define (reverse-using-left items) 
   (fold-left (lambda (result first) (cons first result)) 
              nil 
              items)) 
", 
    tests: 
    [ { input: "(define items (list 1 2 3 4 5)) 
    (reverse-using-right items) 
    (reverse-using-left items) ", expected: "(5 4 3 2 1)
    (5 4 3 2 1)"}    
    ]
},



{ program: "
(define (func inner)
  (lambda (x) (begin (set! inner (* inner x)) inner)))

(define f
  (func 1))
", 
    tests: 
    [ { input: "(+ (f 0) (f  1))", expected: "0"}   
    ]
},


{ program: "
(define (insert-quene! quene item)
  (let ((new-pair (cons item '())))
    (cond ((empty-quene? quene)
	   (set-front-ptr! quene new-pair)
	   (set-rear-ptr! quene new-pair)
	   quene)
    (else
     (set-cdr! (rear-ptr quene) new-pair)
     (set-rear-ptr! quene new-pair)
     quene))))

(define (delete-quene! q)
  (cond ((empty-quene? q)
	 (error 'DELETE! call with an empty quene' q))
	 (else
	  (set-front-ptr! q (cdr (front-ptr q)))))
  q)

(define make-quene
  (cons '() '()))


(define (front-ptr q)
  (car q))

(define (rear-ptr q)
  (cdr q))

(define (empty-quene? q)
  (and (null? (front-ptr q)) (null? (rear-ptr q))))

(define (set-front-ptr! quene item)
  (set-car! quene item))

(define (set-rear-ptr! quene item)
  (set-cdr! quene item))

(define q1 make-quene)


(define (print-quene q)
  (display (front-ptr q)))

", 
    tests: 
    [ { input: "(insert-quene! q1 'a)


    (insert-quene! q1 'b)
    
    (delete-quene! q1)
    
    (delete-quene! q1)
    
    (print-quene q1)",
     expected: "((a) a)
    ((a b) b)
    ((b) b)
    (() b)
    ()"}   
    ]
},



{ program: "
(define (count-pair-imprv x)
  (cond ((not (pair? x)) 0)
	((eq? (car x) (cdr x)) (+ 1 (count-pair-imprv (cdr x))))
	(else (+ 1 (count-pair-imprv (car x)) (count-pair-imprv (cdr x))))))

(define x (list 'a 'b 'c))

(define y (cons x x))
", 
    tests: 
    [ { input: "(count-pair-imprv y)", expected: "4"}   
    ]
},



{ program: "
(define (count-pair-imprv x)
  (cond ((not (pair? x)) 0)
	((eq? (car x) (cdr x)) (+ 1 (count-pair-imprv (cdr x))))
	(else (+ 1 (count-pair-imprv (car x)) (count-pair-imprv (cdr x))))))

(define x (list 'a 'b 'c))

(define y (cons x x))
", 
    tests: 
    [ { input: "(count-pair-imprv y)", expected: "4"}   
    ]
},


{ program: "
(define (make-deque)
  (let ((front-ptr '())
  	(ahead-rear '())
  	(rear-ptr '()))


    (define (front-insert! item)
      (let ((new-pair (list item)))
    	(cond ((empty?)
    	       (set! front-ptr new-pair)
    	       (set! rear-ptr new-pair)
    	       front-ptr)
    	      (else (set! front-ptr (cons item front-ptr))
    		    front-ptr))))
    
    (define (front-delete!)
      (cond ((empty?) (error "quene empty -- FRONT-DELETE"))
    	    (else (set! front-ptr (cdr front-ptr))
    		  (if (null? front-ptr)
    		      (set! rear-ptr '()))
    		  front-ptr)))

    
    (define (delete-rear!)
      (define (helper deque)
	(cond ((empty?) (error "empty deque -- AHEAD-REAR"))
	      ((null? (cdr deque)) '())
	      ((null? (cdr (cdr deque))) (list (car deque)))
	      (else (cons (car deque) (helper (cdr deque))))))
      (set! front-ptr (helper front-ptr))
      front-ptr)
      
 	      
    (define (empty?)
      (null? front-ptr))

    (define (dispatch m)
      (cond ((eq? m 'front-insert!) front-insert!)
	    ((eq? m 'front-delete!) front-deleted!)
	    ((eq? m 'delete-rear!) delete-rear!)
	    (else (error "unknown operation -- DISPATCH" m))))
    dispatch))




(define a (make-deque))
", 
    tests: 
    [ { input: "((a 'front-insert!) 'k)", expected: "(k)"}   
    ]
},

{ program: "
(define (count-pair-imprv x)
  (cond ((not (pair? x)) 0)
	((eq? (car x) (cdr x)) (+ 1 (count-pair-imprv (cdr x))))
	(else (+ 1 (count-pair-imprv (car x)) (count-pair-imprv (cdr x))))))

(define x (list 'a 'b 'c))

(define y (cons x x))
", 
    tests: 
    [ { input: "(count-pair-imprv y)", expected: "4"}   
    ]
},



{ program: "
(define (identity x)
  (cond ((not (pair? x)) x)
	(else (cons (identity (car x)) (identity (cdr x))))))




(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))

(define (fringe tree)
  (cond ((not (pair? tree))
	 (if (null? tree)
	     '()
	     (list tree)))
	(else (append (fringe (car tree)) (fringe (cdr tree))))))

", 
    tests: 
    [ { input: "(fringe (list 1 2 3(list 4 5) (list 5 6) 6))", expected: "(1 2 3 4 5 5 6 6)"}   
    ]
},



{ program: "
(define (product term a next b)
    (if (> a b)
        1
        (* (term a)
           (product term (next a) next b))))", 
    tests: 
    [ { input: "(product (lambda (x) x) 1(lambda (i) (+ i 1))10)", expected: "3628800"}   
    ]
},


{ program: "
(define (product term a next b)
    (define (iter a result)
        (if (> a b)
            result
            (iter (+ a 1)
                  (* (term a) result))))
    (iter a 1))", 
    tests: 
    [ { input: "(product (lambda (x) x) 1 (lambda (i) (+ i 1)) 10)", expected: "3628800"}   
    ]
},


{ program: "
(define (mystery x)
  (define (loop x y)
    (if (null? x)
	y
	(let ((tmp (cdr x)))
	  (set-cdr! x y)
	  (loop tmp x))))
  (loop x '()))
(define v (list 'a 'b 'c 'd))

(define w (mystery v))", 
    tests: 
    [ { input: "w", expected: "(d c b a)"}   
    ]
},



{ program: "
(define (cons  x y)
  (lambda (m) (m x y)))

(define (car z)
  (z (lambda (p q) p)))


(define (cdr z)
  (z (lambda (p q) q)))
", 
    tests: 
    [ { input: "(car (cons 1 2))", expected: "1"}   
    ]
},


{ program: "
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
", 
    tests: 
    [ { input: "(length '(a b c) )", expected: "3"}   
    ]
},


{ program: "
(define (square x)
  (* x x))
(define (map proc items)
  (cond ((null? items) items)
	(else (cons (proc (car items)) (map proc (cdr items))))))

(define (square-tree tree)
  (cond ((null? tree) '())
	((not (pair? tree)) (square tree))
	(else (cons (square-tree (car tree))
		    (square-tree (cdr tree))))))



 
(define (square-tree-map tree)
  (map (lambda (subtree)
	 (cond ((pair? subtree) (square-tree-map subtree))
	       (else (square subtree))))

       tree))
", 
    tests: 
    [ { input: "(square-tree-map (list 2 3 5 (list 5 6) 5 (list 22 3)))", expected: "(4 9 25 (25 36) 25 (484 9))"}   
    ]
},

{ program: "(if (> 3 2) (- 3 2) (+ 3 2))", 
    tests: 
    [ { input: "", expected: "1"}   
    ]
},

{ program: "(define x 2) (set! x 4)", 
    tests: 
    [ { input: "(+ x 1)", expected: "5"}   
    ]
},


{ program: "(cond ((> 3 2) 'greater) ((< 3 2) 'less))", 
    tests: 
    [ { input: "", expected: "greater"}   
    ]
},

{ program: "(cond ((> 3 3) 'greater) ((< 3 3) 'less) (else 'equal))", 
    tests: 
    [ { input: "", expected: "equal"}   
    ]
},

{ program: "(and (= 2 2) (> 2 1))", 
    tests: 
    [ { input: "", expected: "true"}   
    ]
},

{ program: "(and (= 2 2) (< 2 1))", 
    tests: 
    [ { input: "", expected: "false"}   
    ]
},

{ program: "(and 1 2 'c '(f g))", 
    tests: 
    [ { input: "", expected: "(f g)"}   
    ]
},

{ program: "(and 1 2 'c '(f g))", 
    tests: 
    [ { input: "", expected: "(f g)"}   
    ]
},

{ program: "(and)", 
    tests: 
    [ { input: "", expected: "true"}   
    ]
},



{ program: "(or (= 2 2) (> 2 1))", 
    tests: 
    [ { input: "", expected: "true"}   
    ]
},

{ program: "(or #f #f #f)", 
    tests: 
    [ { input: "", expected: "false"}   
    ]
},


{ program: "(let ((x 2) (y 3)) (* x y))", 
    tests: 
    [ { input: "", expected: "6"}   
    ]
},


{ program: "(let ((x 2) (y 3)) (let ((x 7) (z (+ x y))) (* z x))", 
    tests: 
    [ { input: "", expected: "35"}   
    ]
},


{ program: "(let ((x 2) (y 3)) (let* ((x 7) (z (+ x y)))  (* z x)))", 
    tests: 
    [ { input: "", expected: "70"}   
    ]
},



{ program: "(let ((x 2) (y 3)) (let* ((x 7) (z (+ x y)))  (* z x)))", 
    tests: 
    [ { input: "", expected: "70"}   
    ]
},


{ program: "(define x 0)", 
    tests: 
    [ { input: "(begin (set! x 5) (+ x 1)) ", expected: "6"}   
    ]
},



{ program: "((lambda x x) 3 4 5 6)", 
    tests: 
    [ { input: "", expected: "(3 4 5 6)"}   
    ]
},


{ program: "((lambda (x y . z) z) 3 4 5 6) ", 
    tests: 
    [ { input: "", expected: "(5 6)"}   
    ]
},



{ program: "(define reverse-subtract (lambda (x y) (- y x))) (reverse-subtract 7 10) ", 
    tests: 
    [ { input: "", expected: "3"}   
    ]
},


{ program: "((if #f + *) 3 4)", 
    tests: 
    [ { input: "", expected: "12"}   
    ]
},


{ program: "(define first car)", 
    tests: 
    [ { input: "(first '(1 2))", expected: "1"}   
    ]
},


{ program: "(let ((x 5)) (define foo (lambda (y) (bar x y))) (define bar (lambda (a b) (+ (* a b) a))) (foo (+ x 3)))", 
    tests: 
    [ { input: "", expected: "45"}   
    ]
},


{ program: "(not #t)", 
    tests: 
    [ { input: "", expected: "false"}   
    ]
},


{ program: "(not (list))", 
    tests: 
    [ { input: "", expected: "false"}   
    ]
},



{ program: "(let ((x '(a))) (eq? x x)) ", 
    tests: 
    [ { input: "", expected: "true"}   
    ]
},


{ program: "(let ((p (lambda (x) x))) (eq? p p))", 
    tests: 
    [ { input: "", expected: "true"}   
    ]
},


{ program: "(let ((p (lambda (x) x))) (eq? p p))", 
    tests: 
    [ { input: "", expected: "true"}   
    ]
},


{ program: "(eq? car car)", 
    tests: 
    [ { input: "", expected: "true"}   
    ]
},

{ program: "(eq? '() '())", 
    tests: 
    [ { input: "", expected: "true"}   
    ]
},

{ program: "(eq? '() '())", 
    tests: 
    [ { input: "", expected: "true"}   
    ]
},

{ program: "(eq? 'mISSISSIppi 'mississippi)", 
    tests: 
    [ { input: "", expected: "true"}   
    ]
},



{ program: "(let ((=> #f)) (cond (#t => 'ok)))", 
    tests: 
    [ { input: "", expected: "ok"}   
    ]
},


{ program: "(define add4 (let ((x 4)) (lambda (y) (+ x y)))) (add4 6)", 
    tests: 
    [ { input: "", expected: "10"}   
    ]
},



{ program: "(define add4 (let ((x 4)) (lambda (y) (+ x y)))) (add4 6)", 
    tests: 
    [ { input: "", expected: "10"}   
    ]
},

{ program: "(eqv? (cons 1 2) (cons 1 2))", 
    tests: 
    [ { input: "", expected: "false"}   
    ]
},


{ program: "(equal? "abc" "abc")", 
    tests: 
    [ { input: "", expected: "true"}   
    ]
},

{ program: "(equal? "abc" "abc")", 
    tests: 
    [ { input: "", expected: "true"}   
    ]
},

{ program: "(append '(a b) '(c . d))", 
    tests: 
    [ { input: "", expected: "(a b c . d)"}   
    ]
},

]