# Scheme-slang developer documentation

Scheme is a minimalist dialect of the Lisp family of programming languages. Scheme consists of a small standard core with several tools for langauage extension.

This documentation is intended for developers who might maintain or extend the scheme-slang project in the future. It assumes acknowledge of the implemented language. If you haven't read our user documentation, you might want to read it first.

## Roots from js-slang

The repository is based on the template repository set up for CS4215 projects, which in turn is a stripped-down version of js-slang. Our implementation reuses the repl, the scheduler (though in our case the scheduler is not necessary), and `Context` defined in js-slang. The parser, interpreter and test facilities are our new additions.

## Sublanguages

3 sublangages (`base`, `no-tco`, `macro`) are implemented. Based on the sublanguage selected, some features can be turned off. For example, `base` has no macro support while `no-tco` has no proper tail call support. The sublanguages are defined mainly for comparison purpose to showcase the power of the features. The details will be discussed in the specific sections below.

## Architecture Overview

The architecture of the project is summarised in the following diagram. A black box denotes a directory or a logical component. A yellow box denotes a TypeScript file or module. A red arrow denotes dependency. Each component will be further elaborated below.

![Architecture diagram](./docs/architecture-diagram.svg)

## Representation of syntax nodes

A scheme program is formed by many s-expressions. The definitions for such s-expressions are in `src/sExpression.ts` and `src/lang/syntax.ts`. An abstract syntax tree (AST) for Scheme is then a tree with such s-expressions as its nodes.

## Representation of runtime values

A runtime value in Scheme can be an s-expression, a procedure, a `TailCall` object, or a macro. They are defined in `src/sExpression.ts` and `src/interpreter/value.ts`.

## Parser

The file `src/parser/parser.ts` exposes a single `parse` function that converts a program string to an AST. The `parse` function first invokes a parser generated by [antlr4ts](https://github.com/tunnelvisionlabs/antlr4ts) to obtain a parse tree, and then converts the parse tree into an AST.

The [antlr/grammars-v4](https://github.com/antlr/grammars-v4) repository defines the grammar for some languages in ANTLR 4 format. However, there was no ready-made grammar for Scheme. Therefore, we wrote the grammar ourselves in `src/lang/Scheme.g4`. When doing so, we referenced the grammars for [Clojure](https://github.com/antlr/grammars-v4/tree/master/clojure) and [S-Expresssion](https://github.com/antlr/grammars-v4/tree/master/sexpression).

## Interpreter

The interpreter handles the evaluation of an AST generated by the parser. The interpreter consists of a few components as elaborated below.

### Evaluators

`src/interpreter/interpreter.ts` defines the outline of the interpreter. The interpreter recursively evaluates each node of the AST, dispatching different evaluators according to the node types.

The evaluators are defined in the `evaluators` object. The evaluators for self-evaluating values and variables are straight-forward. What's interesting is the evaluator for lists. Since special forms (e.g., `(define x 10)`), procedure invocations (e.g., `(factorial 10)`) and macro use (e.g., `(let ((x 10)) (+ x 2))`) are all written as a list in Scheme syntax, the evaluator for lists has to distinguish between these 3 cases by looking at the first element in the list, and then dispatch the corresponding evaluator, which are elaborated below.

### Procedure invocation

The code for handling procedure invocations are in `src/interpreter/procedure.ts`. It has facilities to check number of arguments, match parameter names to arguments (for procedures with fixed number of arguments, this is trivial; for procedures with var-args, we need to lump all the non-compulsory arguments into a list and assigned it to the last parameter), extend the procedure environment, and handle tail calls.

#### Proper tail calls

R5RS requires Scheme implementations to be _properly tail recursive_ by supporting unbounded number of tail calls. Note that this is not limited to recursive procedure calls - non-recursive or mutually recursive tail calls must be optimised as well.

In scheme-slang, unbounded number of tail calls can only fail because of stackoverflow in the underlying JavaScript or running out of space by creating too many new environment frames. To implement proper tail calls, we address these limitations in the following way:

1. A tail call is not immediately evaluated. Instead, it is wrapped in a `TailCall` object and returned.
2. When invoking a procedure (more specifically, in the `applyCompoundProcedure` function in `src/interpreter/procedure.ts`), if the last expression in the procedure body evaluates to a `TailCall` object, instead of calling `evaluate` recursively (which can cause stackoverflow or create more environment frames), we repeat the function body but replace the procedure and arguments with those from the `TailCall` object. Do this until a non `TailCall` object is returned.

This way, tail calls do not consume additional space. We can then support unbounded number of tail calls.

What remains to be implemented is the identification of tail calls. Our implementation simply follows the inductive definition (see specifications) of tail calls by maintaining whether the node being evaluated is in tail context. Any call expression in tail context are then regarded as a tail call.

The `no-tco` sublanguage turns off proper tail calls.

### Special forms

Lists like `(define x 10)` and `(if #t 1 2)` look like procedures, but they have special evaluation rules. The interpreter has a dedicated component for evaluating special forms.

`src/interpreter/specialForm/definitions` defines object types that represent special forms. For example, `(if #t 1 2)` will be represented as an `IfForm`.

`src/interpreter/specialForm/converters.ts` defines functions that convert a syntactic list to its object representation as defined in `src/interpreter/specialForm/definitions.ts`. Any ill-formed special form should be caught by the converters and not reach the evaluators.

`src/interpreter/specialForm/evaluators.ts` defines the evaluators for special forms. Each evaluator takes in the object representation of a special form and evaluates it according to its special evaluation rules.

Based on the sublanguage selected, some special forms are disabled. The `base` sublanguage enables all 20 special forms except for `defmacro`. The `macro` sublanguage only enables `defmacro`, `define`, `set!`, `if`, `lambda`, `quote`, `quasiquote`, `unquote`, `unquote-splicing`, because the other special forms are defined using macros as part of the standard library.

### Quotation

Although Scheme has special syntax for quotation like `'(list 1 2)` and `` `(1 2 ,(+ 1 2))``, there are equivalent to their list representations (`(quote (list 1 2))`, `(quasiquote (1 2 (unquote (+ 1 2))))`) in all aspects. Therefore, the special syntaxes are converted to their list representations during AST construction. The list representations will then be evaluated as special forms.

The definitions for quotation and quasiquotation can be quite involved. Each type of syntax node has its own rules for quotation and quasiquotaton. For example, quasiquoting a number just returns the number itself, but quasiquoting a list requires recursive quasiquotation of all its elements, and making sure no illegal unquotation and splicing unquotation are used within it. Other syntax nodes have their own rules.

Notice the parallel between quotation and interpretation, in the sense that a rule is defined for each type of syntax node. Indeed, in some sense, quotation can be thought of as another interpreter with a different set of evaluation rules. The use of unquotation within quasiquotation can then be thought of as toggling between these two modes of evaluation on demand.

Due to the complexity of quotation, instead of being defined in `src/interpreter/specialForm/evaluators.ts`, it has its own module `src/interpreter/quote.ts`. For each type of syntax node, this file defines a rule for quotation and quasiquotation according to the specifications.

### Macros

`src/interpreter/macro.ts` defines the evaluator for using macros.

When evaluating a macro use, the following steps happen:

1. Convert the syntax nodes passed to the macro to values.
2. Bind the values to the parameters of the macro.
3. Evaluate the macro body to obtain a value as the result.
4. Convert the result to a syntax node.
5. Evaluate the resultant syntax node.

This can seem contradictory to the denotational semantics outlined in our language specification. Technically, due to homoiconicity, the syntactic domain and semantic domain overlaps. If so, then why do we need the conversion in step 1 and 4? The reason is twofold:

1. Although a syntactic list and a semantic list should belong in the same domain, our implementation actually represents them as two distinct types `SyntaxList` (for syntactic list) and `Pair` (for semantic list). Recall the definition of a list in Scheme: a list is a chain of pairs that ends with the empty list. For semantic lists, we follow this specification faithfully. For syntactic lists, however, we deviate from this approach by using an array to hold the list elements. This makes it more convenient and efficient for the interpreter to access the elements by index. The efficiency gain comes from both constant time random access (as opposed to `O(n)` lookup with `list-ref` using pair representation) and potentially higher cache hit rates (due to spatial locality of the array elements).
Therefore, before macro expansion, we need to convert syntactic lists to semantic lists so that the macro body can manipulate them as values. After the macro body is evaluated, we need to convert the semantic lists in the result back to syntactic lists so that the interpreter can continue to treat them as syntax.

2. The result of the macro body must be valid syntax. Therefore, it must not evaluate to a non s-expression value like a procedure. If it does, we need to catch this and throw an error.

Note that our macro expansion system is unhygienic. It does not automatically rename the identifiers introduced within the macro body, so unintended captures are possible. This deviates from R5RS, which requires macros defined to be automatically hygienic. We did not have time to build such a complex system. This can be a possible future extension.

#### Generating unique symbols with `gensym`

We provide the `gensym` procedure as seen in Common Lisp. Each invocation of the procedure returns a unique symbol that is guaranteed not to be used anywhere else. This is useful for defining hygienic macros under our unhygienic macro expansion system.

To ensure we return a unique symbol for each invocation, the interpreter maintains a global counter that increments after each invocation of `gensym`, and embed the value of the counter at time of invocation into the symbol.

However, what's preventing the user from defining a symbol that conflicts with the one returned by `gensym`? To provide this guarantee, we need some additional mechanisms. The symbols generated by `gensym` has a unique prefix (currently `$:`). Also, we attach a little bit of metadata onto each symbol to indicate whether this symbol is generated by `gensym`. When the interpreter sees a definition of a symbol that starts with the prefix, it only allows such definition to pass through if the symbol was defined using `gensym`.

With such mechanisms in place, we fulfill the guarantees of `gensym` and give the programmer the ability to write hygienic macros.

## Built-in procedures

Built-in procedures are those defined in the underlying TypeScript. They are typecially either primitive operations (e.g., arithmetic operations) or operations that cannot be defined by the programmer (e.g., `gensym` and `macroexpand`). A number of built-in procedures are defined in files under the `src/builtIns` directory.

The built-in procedures are loaded into the global environment frame upon context creation.

## Standard library

Our implementation provides a small but useful standard library. Contrary to the built-ins, it is perfectly possible for the programmer to define the content of the standard library. We only provide it for convenience.

The standard library is defined in 2 files: `src/stdlib/procedures.prelude.ts` and `src/stblib/macros.prelude.ts`. We load the former in all circumstances and the latter only when macros are enabled. For details of their content, please refer to our specifications.

The mechanism we use to load the standard library is rather primitive: we simply evaluate the standard library as a prelude to populate the global environment before evaluating the user code.

Additionally, we included the meta-circular evaluator presented in the original SICP in `src/stdlib/sicpMce.ts`. It is included for testing, and also loaded as the default program when the frontent is first opened.

## Tests

We have a comprehensive test suite with high code coverage. All the interpreter features (including proper tail calls), built-in procedures, and the standard library are tested. We run our tests using all 3 sublanguages to ensure they behave the same. We also run some of our test cases in the meta-circular evaluator as an integration test and expect the same result as they are run 'navitely'.
